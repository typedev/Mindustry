# Техническая документация мода Snake Units для Mindustry

## Общее описание

Snake Units — это мод для игры Mindustry, который добавляет змееподобные юниты, состоящие из головы и нескольких следующих за ней сегментов. Мод реализует сложную систему движения, обеспечивающую плавное следование сегментов за головой независимо от типа управления (ИИ или ручное).

## Архитектура системы

### Основные компоненты

1. **Голова змеи** (`serpent-head`) — основной юнит, управляемый игроком или ИИ
2. **Сегменты змеи** (`serpent-segment`) — следующие за головой части тела
3. **Глобальная система управления** (`snakeSystem`) — центральный контроллер всех змей
4. **Система сглаживания движения** — алгоритмы устранения дрожания и обеспечения плавности

### Структура данных змеи

```javascript
var snake = {
    head: headUnit,                 // Ссылка на юнит головы
    segments: new Seq(),           // Массив сегментов
    maxSegments: 5,                // Максимальное количество сегментов
    segmentSpacing: 10,            // Расстояние между сегментами (в игровых единицах)
    updateCounter: 0,              // Счетчик обновлений
    headHistory: new Seq(),        // История позиций головы
    historySize: 20               // Размер истории для сглаживания
}
```

## Алгоритмы и системы

### 1. Система создания змей

**Триггер:** Event `UnitCreateEvent`
**Условие:** `unit.type.name.equals("snake-units-serpent-head")`

```javascript
Events.on(EventType.UnitCreateEvent, cons(event => {
    if (unit.type && unit.type.name.equals("snake-units-serpent-head")) {
        snakeSystem.createSnake(unit);
    }
}));
```

**Процесс создания:**
1. Создание объекта змеи с начальными параметрами
2. Регистрация в глобальном HashMap по ID головы
3. Инициализация истории позиций
4. Отложенное создание сегментов (через 5 обновлений)

### 2. Система обновления позиций

**Частота:** 60 FPS (обновление каждые 16ms)
**Реализация:** `Timer.schedule(() => { snakeSystem.update(); }, 0, 0.016)`

#### Алгоритм обновления змеи:

```
1. Увеличить updateCounter
2. Записать текущую позицию головы в историю
3. Каждые 20 обновлений проверить валидность головы
4. Если сегментов нет и updateCounter > 5 — создать сегменты
5. Очистить невалидные сегменты
6. Обновить позиции всех сегментов
```

### 3. Система создания сегментов

**Условия активации:**
- Отсутствие сегментов (`segments.size === 0`)
- Минимальная задержка (`updateCounter > 5`)

**Процесс создания:**
1. Поиск типа юнита `snake-units-serpent-segment`
2. Создание сегментов позади головы с интервалом `segmentSpacing`
3. Установка команды сегментов равной команде головы
4. Добавление в массив сегментов

### 4. Алгоритм движения сегментов

#### Система целевых позиций:

**Первый сегмент:**
- Следует за сглаженной позицией головы с задержкой 1 кадр
- Цель: `getSmoothedHeadPosition(1)`

**Остальные сегменты:**
- Следуют за сглаженной позицией предыдущего сегмента
- Цель: `getSmoothedSegmentPosition(prevSegment, 2)`

#### Логика движения по расстоянию:

```javascript
var dist = Math.sqrt(dx * dx + dy * dy);
var minMoveThreshold = 1.5;

if (dist < minMoveThreshold) {
    // Игнорировать микродвижения
    continue;
} else if (dist > segmentSpacing * 2.0) {
    // Мгновенная телепортация для больших расстояний
    segment.set(desiredX, desiredY);
} else if (dist > segmentSpacing * 0.7) {
    // Плавная интерполяция для средних расстояний
    var moveSpeed = 0.25;
    segment.set(segment.x + moveX, segment.y + moveY);
}
```

### 5. Система сглаживания

#### История позиций головы:

```javascript
getSmoothedHeadPosition(delay) {
    var historyIndex = this.headHistory.size - 1 - delay;
    return this.headHistory.get(historyIndex);
}
```

**Принцип:** Сегменты следуют не за текущей позицией головы, а за позицией из прошлого, что создает естественную задержку и плавность.

#### Сглаживание позиций сегментов:

```javascript
getSmoothedSegmentPosition(segment, smoothingFactor) {
    var smoothingAmount = 1.0 / smoothingFactor;
    var smoothedX = segment.lastX + (currentPos.x - segment.lastX) * smoothingAmount;
    var smoothedY = segment.lastY + (currentPos.y - segment.lastY) * smoothingAmount;
    return new Vec2(smoothedX, smoothedY);
}
```

### 6. Система очистки ресурсов

#### Автоматическая очистка:
- **По таймеру:** Проверка валидности каждые 20 обновлений
- **По событию:** `UnitDestroyEvent` для немедленной очистки

#### Процедура cleanup():
1. Уничтожение всех сегментов (`segment.kill()`)
2. Очистка массива сегментов
3. Очистка истории позиций
4. Удаление из глобального HashMap

## Параметры конфигурации

### Основные параметры движения:

| Параметр | Значение | Описание |
|----------|----------|----------|
| `maxSegments` | 5 | Количество сегментов тела |
| `segmentSpacing` | 10 | Расстояние между сегментами |
| `historySize` | 20 | Размер буфера истории позиций |
| `minMoveThreshold` | 1.5 | Минимальное расстояние для движения |
| `moveSpeed` | 0.25 | Скорость интерполяции движения |

### Пороговые значения:

| Условие | Поведение |
|---------|-----------|
| `dist < 1.5` | Остановка (устранение дрожания) |
| `dist > segmentSpacing * 2.0` | Мгновенная телепортация |
| `segmentSpacing * 0.7 < dist < segmentSpacing * 2.0` | Плавная интерполяция |

### Временные параметры:

| Параметр | Значение | Назначение |
|----------|----------|------------|
| Частота обновлений | 60 FPS | Плавность движения |
| Задержка создания сегментов | 5 кадров | Стабилизация головы |
| Проверка валидности | Каждые 20 кадров | Производительность |
| Задержка первого сегмента | 1 кадр | Отзывчивость |

## Технические особенности

### Использование Arc Framework:

```javascript
// Коллекции
var segments = new Seq();           // Динамический массив
var headHistory = new Seq();        // История позиций

// Векторы
var headPos = new Vec2(x, y);       // 2D вектор позиции

// Функциональные интерфейсы
segments.each(cons(segment => {})); // Итерация с консьюмером
```

### Управление памятью:

- **HashMap** для быстрого доступа к змеям по ID
- **Ограниченная история** позиций (максимум 20 кадров)
- **Автоматическая очистка** невалидных объектов
- **Переиспользование** векторов позиций

### Обработка ошибок:

```javascript
// Проверка валидности перед операциями
if (!segment || !segment.isValid()) continue;

// Безопасная работа с индексами
if (historyIndex >= 0 && historyIndex < this.headHistory.size) {
    return this.headHistory.get(historyIndex);
}

// Fallback значения
} else if (this.headHistory.size > 0) {
    return this.headHistory.get(this.headHistory.size - 1);
} else {
    return new Vec2(this.head.x, this.head.y);
}
```

## Диагностика и отладка

### Система логирования:

```javascript
print("[Snake] Loading snake logic...");           // Инициализация
print("[Snake] Created snake for head " + headUnit.id);  // Создание
print("[Snake] Spawning segments for head " + this.head.id); // Спавн
print("[Snake] Head " + this.head.id + " became invalid"); // Ошибки
```

### Ключевые точки мониторинга:

1. **Создание змей:** Проверка успешной регистрации
2. **Спавн сегментов:** Контроль количества созданных сегментов
3. **Валидность юнитов:** Отслеживание преждевременного уничтожения
4. **Производительность:** Количество активных змей в системе

## Возможности для развития

### 1. Расширение функциональности

#### Дополнительные типы сегментов:
```javascript
// Разные типы сегментов с уникальными способностями
var segmentTypes = ["basic", "armored", "weapon", "support"];
```

#### Динамическое изменение длины:
```javascript
// Увеличение/уменьшение сегментов в зависимости от условий
snake.addSegment();
snake.removeSegment();
```

#### Специальные способности:
```javascript
// Атаки всего тела змеи
snake.bodySlam();
// Разделение на части
snake.split();
// Регенерация сегментов
snake.regenerate();
```

### 2. Улучшение алгоритмов

#### Предиктивное движение:
```javascript
// Предсказание будущей позиции головы
var predictedPos = head.pos + head.velocity * predictionTime;
```

#### Физическая симуляция:
```javascript
// Симуляция гибкости тела змеи
segment.applyPhysics(prevSegment, nextSegment);
```

#### Адаптивная скорость:
```javascript
// Изменение скорости в зависимости от ситуации
var adaptiveSpeed = calculateSpeed(terrain, combat, distance);
```

### 3. Визуальные улучшения

#### Анимация сегментов:
```javascript
// Плавная анимация поворотов и движений
segment.animateRotation(targetAngle, animationSpeed);
```

#### Эффекты следа:
```javascript
// Визуальные эффекты движения змеи
snake.addTrailEffect();
```

#### Динамические текстуры:
```javascript
// Изменение внешнего вида в зависимости от состояния
segment.updateTexture(health, status, environment);
```

### 4. Игровая механика

#### Система роста:
```javascript
// Рост змеи при поглощении ресурсов
snake.consume(resource);
snake.grow();
```

#### Кооперативные змеи:
```javascript
// Взаимодействие между несколькими змеями
snakeSystem.formPack(snake1, snake2);
```

#### Тактические формации:
```javascript
// Различные построения для боя
snake.setFormation("defensive", "offensive", "stealth");
```

### 5. Оптимизация производительности

#### Пулинг объектов:
```javascript
var segmentPool = new ObjectPool(SegmentType);
```

#### Октальное дерево для коллизий:
```javascript
var spatialIndex = new QuadTree(worldBounds);
```

#### Уровни детализации:
```javascript
// Упрощение логики для удаленных змей
if (distanceToPlayer > LOD_DISTANCE) {
    snake.updateSimplified();
}
```

## Заключение

Мод Snake Units представляет собой сложную систему, сочетающую в себе продвинутые алгоритмы движения, эффективное управление ресурсами и гибкую архитектуру для расширения. Текущая реализация обеспечивает стабильную работу с плавным движением сегментов независимо от типа управления головой змеи.

Ключевые преимущества архитектуры:
- **Независимость от ИИ:** Работает с любым типом управления
- **Масштабируемость:** Поддержка множественных змей
- **Производительность:** Оптимизированные алгоритмы обновления
- **Расширяемость:** Модульная структура для добавления новых функций

Данная документация обеспечивает полное понимание системы для дальнейшей разработки и модификации мода. 